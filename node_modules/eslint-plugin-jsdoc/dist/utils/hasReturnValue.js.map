{"version":3,"file":"hasReturnValue.js","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","typeParameters","params","undefinedKeywords","Set","hasReturnValue","throwOnNullReturn","promFilter","returnType","typeAnnotation","has","value","expression","body","some","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","nde","argument","Error","allBrancheshaveReturnValues","lastBodyNode","slice","error","message","every","hasNonEmptyResolverCall","resolverName","arguments","length","undefined","test","elements","element","right","left","expressions","subExpression","properties","property","decorators","decorator","computed","key","declarations","id","init","quasi","object","source","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","allBranches","hasReturnMethod","promiseFilter","hasReturn","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/* eslint-disable jsdoc/no-undefined-types */\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\nconst isVoidPromise = (node) => {\n  return node?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSVoidKeyword', 'TSUndefinedKeyword', 'TSNeverKeyword',\n]);\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @param {boolean} throwOnNullReturn\n * @param {PromiseFilter} promFilter\n * @returns {boolean|Node}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, throwOnNullReturn, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  case 'MethodDefinition':\n    return hasReturnValue(node.value, throwOnNullReturn, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, throwOnNullReturn, promFilter);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.alternate, throwOnNullReturn, promFilter);\n  }\n\n  case 'TryStatement': {\n    return hasReturnValue(node.block, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.finalizer, throwOnNullReturn, promFilter);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasReturnValue(nde, throwOnNullReturn, promFilter);\n        });\n      },\n    );\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      if (throwOnNullReturn) {\n        throw new Error('Null return');\n      }\n\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @param {PromiseFilter} promFilter\n * @returns {boolean|Node}\n */\n// eslint-disable-next-line complexity\nconst allBrancheshaveReturnValues = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  // case 'MethodDefinition':\n  //   return allBrancheshaveReturnValues(node.value, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      allBrancheshaveReturnValues(node.body, promFilter);\n  }\n\n  case 'BlockStatement': {\n    const lastBodyNode = node.body.slice(-1)[0];\n    return allBrancheshaveReturnValues(lastBodyNode, promFilter);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return allBrancheshaveReturnValues(node.body, promFilter);\n  }\n\n  case 'IfStatement': {\n    return allBrancheshaveReturnValues(node.consequent, promFilter) && allBrancheshaveReturnValues(node.alternate, promFilter);\n  }\n\n  case 'TryStatement': {\n    // If `finally` returns, all return\n    return node.finalizer && allBrancheshaveReturnValues(node.finalizer, promFilter) ||\n      // Return in `try`/`catch` may still occur despite `finally`\n      allBrancheshaveReturnValues(node.block, promFilter) &&\n        (!node.handler ||\n          allBrancheshaveReturnValues(node.handler && node.handler.body, promFilter)) &&\n          (!node.finalizer || (() => {\n            try {\n              hasReturnValue(node.finalizer, true, promFilter);\n            } catch (error) {\n              // istanbul ignore else\n              if (error.message === 'Null return') {\n                return false;\n              }\n\n              // istanbul ignore next\n              throw error;\n            }\n\n            // As long as not an explicit empty return, then return true\n            return true;\n          })());\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.every(\n      (someCase) => {\n        const nde = someCase.consequent.slice(-1)[0];\n        return !nde || allBrancheshaveReturnValues(nde, promFilter);\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @callback PromiseFilter\n * @param {object} node\n * @returns {boolean}\n */\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n *\n * @param {AST} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.callee.name === resolverName && (\n\n      // Implicit or explicit undefined\n      node.arguments.length > 1 || node.arguments[0] !== undefined\n    ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n  case 'ChainExpression':\n  case 'Decorator':\n  case 'ExpressionStatement':\n    return hasNonEmptyResolverCall(node.expression, resolverName);\n  case 'ClassBody':\n  case 'BlockStatement':\n    return node.body.some((bodyNode) => {\n      return hasNonEmptyResolverCall(bodyNode, resolverName);\n    });\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    // Shadowing\n    if (node.params[0]?.name === resolverName) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n  }\n\n  case 'TryStatement': {\n    return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonEmptyResolverCall(nde, resolverName);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonEmptyResolverCall(element, resolverName);\n    });\n\n  case 'AssignmentPattern':\n    return hasNonEmptyResolverCall(node.right, resolverName);\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonEmptyResolverCall(subExpression, resolverName);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonEmptyResolverCall(property, resolverName);\n    });\n  // istanbul ignore next -- In Babel?\n  case 'ClassMethod':\n  case 'MethodDefinition':\n    return node.decorators && node.decorators.some((decorator) => {\n      return hasNonEmptyResolverCall(decorator, resolverName);\n    }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  /* eslint-enable no-fallthrough */\n  case 'Property':\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n  case 'ClassExpression':\n  case 'ClassDeclaration':\n    return hasNonEmptyResolverCall(node.body, resolverName);\n\n  case 'AwaitExpression':\n  case 'SpreadElement':\n  case 'UnaryExpression':\n  case 'YieldExpression':\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonEmptyResolverCall(nde, resolverName);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n  }\n\n  case 'TaggedTemplateExpression':\n    return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonEmptyResolverCall(node.source, resolverName);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n  }\n\n  /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n  default:\n    return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @param {boolean} anyPromiseAsReturn\n * @param {boolean} allBranches\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn, allBranches) => {\n  const hasReturnMethod = allBranches ?\n    (nde, promiseFilter) => {\n      let hasReturn;\n      try {\n        hasReturn = hasReturnValue(nde, true, promiseFilter);\n      } catch (error) {\n        // istanbul ignore else\n        if (error.message === 'Null return') {\n          return false;\n        }\n\n        // istanbul ignore next\n        throw error;\n      }\n\n      // `hasReturn` check needed since `throw` treated as valid return by\n      //   `allBrancheshaveReturnValues`\n      return hasReturn && allBrancheshaveReturnValues(nde, promiseFilter);\n    } :\n    (nde, promiseFilter) => {\n      return hasReturnValue(nde, false, promiseFilter);\n    };\n\n  return hasReturnMethod(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const [\n      {\n        params,\n        body,\n      } = {},\n    ] = prom.arguments;\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const [\n      {\n        name: resolverName,\n      },\n    ] = params;\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,sBAAsB,GAAIC,IAAI,IAAK;EACvC,OAAOA,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAK,eAAe,IAAID,IAAI,CAACE,MAAM,CAACD,IAAI,KAAK,YAAY,IAC/ED,IAAI,CAACE,MAAM,CAACC,IAAI,KAAK,SAAS;AAClC,CAAC;AAED,MAAMC,aAAa,GAAIJ,IAAI,IAAK;EAAA;EAC9B,OAAO,CAAAA,IAAI,aAAJA,IAAI,+CAAJA,IAAI,CAAEK,cAAc,kFAApB,qBAAsBC,MAAM,oFAA5B,sBAA+B,CAAC,CAAC,2DAAjC,uBAAmCL,IAAI,MAAK,eAAe;AACpE,CAAC;AAED,MAAMM,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAChC,eAAe,EAAE,oBAAoB,EAAE,gBAAgB,CACxD,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAG,CAACT,IAAI,EAAEU,iBAAiB,EAAEC,UAAU,KAAK;EAC9D,IAAI,CAACX,IAAI,EAAE;IACT,OAAO,KAAK;EACd;EAEA,QAAQA,IAAI,CAACC,IAAI;IACjB,KAAK,mBAAmB;IACxB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;MAAE;QAAA;QACxB,MAAMA,IAAI,GAAGD,IAAI,aAAJA,IAAI,2CAAJA,IAAI,CAAEY,UAAU,8EAAhB,iBAAkBC,cAAc,0DAAhC,sBAAkCZ,IAAI;QACnD,OAAOA,IAAI,IAAI,CAACM,iBAAiB,CAACO,GAAG,CAACb,IAAI,CAAC;MAC7C;IAEA,KAAK,kBAAkB;MACrB,OAAOQ,cAAc,CAACT,IAAI,CAACe,KAAK,EAAEL,iBAAiB,EAAEC,UAAU,CAAC;IAClE,KAAK,oBAAoB;IACzB,KAAK,qBAAqB;IAC1B,KAAK,yBAAyB;MAAE;QAC9B,OAAOX,IAAI,CAACgB,UAAU,KAAK,CAACjB,sBAAsB,CAACC,IAAI,CAACiB,IAAI,CAAC,IAAI,CAACb,aAAa,CAACJ,IAAI,CAACiB,IAAI,CAAC,CAAC,IACzFR,cAAc,CAACT,IAAI,CAACiB,IAAI,EAAEP,iBAAiB,EAAEC,UAAU,CAAC;MAC5D;IAEA,KAAK,gBAAgB;MAAE;QACrB,OAAOX,IAAI,CAACiB,IAAI,CAACC,IAAI,CAAEC,QAAQ,IAAK;UAClC,OAAOA,QAAQ,CAAClB,IAAI,KAAK,qBAAqB,IAAIQ,cAAc,CAACU,QAAQ,EAAET,iBAAiB,EAAEC,UAAU,CAAC;QAC3G,CAAC,CAAC;MACJ;IAEA,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,eAAe;MAAE;QACpB,OAAOF,cAAc,CAACT,IAAI,CAACiB,IAAI,EAAEP,iBAAiB,EAAEC,UAAU,CAAC;MACjE;IAEA,KAAK,aAAa;MAAE;QAClB,OAAOF,cAAc,CAACT,IAAI,CAACoB,UAAU,EAAEV,iBAAiB,EAAEC,UAAU,CAAC,IACnEF,cAAc,CAACT,IAAI,CAACqB,SAAS,EAAEX,iBAAiB,EAAEC,UAAU,CAAC;MACjE;IAEA,KAAK,cAAc;MAAE;QACnB,OAAOF,cAAc,CAACT,IAAI,CAACsB,KAAK,EAAEZ,iBAAiB,EAAEC,UAAU,CAAC,IAC9DF,cAAc,CAACT,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACN,IAAI,EAAEP,iBAAiB,EAAEC,UAAU,CAAC,IAChFF,cAAc,CAACT,IAAI,CAACwB,SAAS,EAAEd,iBAAiB,EAAEC,UAAU,CAAC;MACjE;IAEA,KAAK,iBAAiB;MAAE;QACtB,OAAOX,IAAI,CAACyB,KAAK,CAACP,IAAI,CACnBQ,QAAQ,IAAK;UACZ,OAAOA,QAAQ,CAACN,UAAU,CAACF,IAAI,CAAES,GAAG,IAAK;YACvC,OAAOlB,cAAc,CAACkB,GAAG,EAAEjB,iBAAiB,EAAEC,UAAU,CAAC;UAC3D,CAAC,CAAC;QACJ,CAAC,CACF;MACH;IAEA,KAAK,iBAAiB;MAAE;QACtB;QACA,IAAIX,IAAI,CAAC4B,QAAQ,KAAK,IAAI,EAAE;UAC1B,IAAIlB,iBAAiB,EAAE;YACrB,MAAM,IAAImB,KAAK,CAAC,aAAa,CAAC;UAChC;UAEA,OAAO,KAAK;QACd;QAEA,IAAIlB,UAAU,IAAIZ,sBAAsB,CAACC,IAAI,CAAC4B,QAAQ,CAAC,EAAE;UACvD;UACA;UACA,OAAOjB,UAAU,CAACX,IAAI,CAAC4B,QAAQ,CAAC;QAClC;QAEA,OAAO,IAAI;MACb;IAEA;MAAS;QACP,OAAO,KAAK;MACd;EAAC;AAEH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA,MAAME,2BAA2B,GAAG,CAAC9B,IAAI,EAAEW,UAAU,KAAK;EACxD,IAAI,CAACX,IAAI,EAAE;IACT,OAAO,KAAK;EACd;EAEA,QAAQA,IAAI,CAACC,IAAI;IACjB,KAAK,mBAAmB;IACxB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;MAAE;QAAA;QACxB,MAAMA,IAAI,GAAGD,IAAI,aAAJA,IAAI,4CAAJA,IAAI,CAAEY,UAAU,+EAAhB,kBAAkBC,cAAc,0DAAhC,sBAAkCZ,IAAI;QACnD,OAAOA,IAAI,IAAI,CAACM,iBAAiB,CAACO,GAAG,CAACb,IAAI,CAAC;MAC7C;;IAEA;IACA;IACA,KAAK,oBAAoB;IACzB,KAAK,qBAAqB;IAC1B,KAAK,yBAAyB;MAAE;QAC9B,OAAOD,IAAI,CAACgB,UAAU,KAAK,CAACjB,sBAAsB,CAACC,IAAI,CAACiB,IAAI,CAAC,IAAI,CAACb,aAAa,CAACJ,IAAI,CAACiB,IAAI,CAAC,CAAC,IACzFa,2BAA2B,CAAC9B,IAAI,CAACiB,IAAI,EAAEN,UAAU,CAAC;MACtD;IAEA,KAAK,gBAAgB;MAAE;QACrB,MAAMoB,YAAY,GAAG/B,IAAI,CAACiB,IAAI,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3C,OAAOF,2BAA2B,CAACC,YAAY,EAAEpB,UAAU,CAAC;MAC9D;IAEA,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,eAAe;MAAE;QACpB,OAAOmB,2BAA2B,CAAC9B,IAAI,CAACiB,IAAI,EAAEN,UAAU,CAAC;MAC3D;IAEA,KAAK,aAAa;MAAE;QAClB,OAAOmB,2BAA2B,CAAC9B,IAAI,CAACoB,UAAU,EAAET,UAAU,CAAC,IAAImB,2BAA2B,CAAC9B,IAAI,CAACqB,SAAS,EAAEV,UAAU,CAAC;MAC5H;IAEA,KAAK,cAAc;MAAE;QACnB;QACA,OAAOX,IAAI,CAACwB,SAAS,IAAIM,2BAA2B,CAAC9B,IAAI,CAACwB,SAAS,EAAEb,UAAU,CAAC;QAC9E;QACAmB,2BAA2B,CAAC9B,IAAI,CAACsB,KAAK,EAAEX,UAAU,CAAC,KAChD,CAACX,IAAI,CAACuB,OAAO,IACZO,2BAA2B,CAAC9B,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACN,IAAI,EAAEN,UAAU,CAAC,CAAC,KAC1E,CAACX,IAAI,CAACwB,SAAS,IAAI,CAAC,MAAM;UACzB,IAAI;YACFf,cAAc,CAACT,IAAI,CAACwB,SAAS,EAAE,IAAI,EAAEb,UAAU,CAAC;UAClD,CAAC,CAAC,OAAOsB,KAAK,EAAE;YACd;YACA,IAAIA,KAAK,CAACC,OAAO,KAAK,aAAa,EAAE;cACnC,OAAO,KAAK;YACd;;YAEA;YACA,MAAMD,KAAK;UACb;;UAEA;UACA,OAAO,IAAI;QACb,CAAC,GAAG,CAAC;MACb;IAEA,KAAK,iBAAiB;MAAE;QACtB,OAAOjC,IAAI,CAACyB,KAAK,CAACU,KAAK,CACpBT,QAAQ,IAAK;UACZ,MAAMC,GAAG,GAAGD,QAAQ,CAACN,UAAU,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC5C,OAAO,CAACL,GAAG,IAAIG,2BAA2B,CAACH,GAAG,EAAEhB,UAAU,CAAC;QAC7D,CAAC,CACF;MACH;IAEA,KAAK,gBAAgB;MAAE;QACrB,OAAO,IAAI;MACb;IAEA,KAAK,iBAAiB;MAAE;QACtB;QACA,IAAIX,IAAI,CAAC4B,QAAQ,KAAK,IAAI,EAAE;UAC1B,OAAO,KAAK;QACd;QAEA,IAAIjB,UAAU,IAAIZ,sBAAsB,CAACC,IAAI,CAAC4B,QAAQ,CAAC,EAAE;UACvD;UACA;UACA,OAAOjB,UAAU,CAACX,IAAI,CAAC4B,QAAQ,CAAC;QAClC;QAEA,OAAO,IAAI;MACb;IAEA;MAAS;QACP,OAAO,KAAK;MACd;EAAC;AAEH,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,uBAAuB,GAAG,CAACpC,IAAI,EAAEqC,YAAY,KAAK;EACtD,IAAI,CAACrC,IAAI,EAAE;IACT,OAAO,KAAK;EACd;;EAEA;EACA,QAAQA,IAAI,CAACC,IAAI;IACjB;IACA,KAAK,wBAAwB;IAC7B,KAAK,gBAAgB;MACnB,OAAOD,IAAI,CAACE,MAAM,CAACC,IAAI,KAAKkC,YAAY;MAEtC;MACArC,IAAI,CAACsC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAIvC,IAAI,CAACsC,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,CAC7D,IACCxC,IAAI,CAACsC,SAAS,CAACpB,IAAI,CAAES,GAAG,IAAK;QAC3B;QACA,OAAOA,GAAG,CAAC1B,IAAI,KAAK,YAAY,IAAI0B,GAAG,CAACxB,IAAI,KAAKkC,YAAY;QAE3D;QACAD,uBAAuB,CAACT,GAAG,EAAEU,YAAY,CAAC;MAC9C,CAAC,CAAC;IACN,KAAK,iBAAiB;IACtB,KAAK,WAAW;IAChB,KAAK,qBAAqB;MACxB,OAAOD,uBAAuB,CAACpC,IAAI,CAACgB,UAAU,EAAEqB,YAAY,CAAC;IAC/D,KAAK,WAAW;IAChB,KAAK,gBAAgB;MACnB,OAAOrC,IAAI,CAACiB,IAAI,CAACC,IAAI,CAAEC,QAAQ,IAAK;QAClC,OAAOiB,uBAAuB,CAACjB,QAAQ,EAAEkB,YAAY,CAAC;MACxD,CAAC,CAAC;IACJ,KAAK,oBAAoB;IACzB,KAAK,qBAAqB;IAC1B,KAAK,yBAAyB;MAAE;QAAA;QAC9B;QACA,IAAI,kBAAArC,IAAI,CAACM,MAAM,CAAC,CAAC,CAAC,kDAAd,cAAgBH,IAAI,MAAKkC,YAAY,EAAE;UACzC,OAAO,KAAK;QACd;QAEA,OAAOD,uBAAuB,CAACpC,IAAI,CAACiB,IAAI,EAAEoB,YAAY,CAAC;MACzD;IAEA,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,eAAe;MAAE;QACpB,OAAOD,uBAAuB,CAACpC,IAAI,CAACiB,IAAI,EAAEoB,YAAY,CAAC;MACzD;IAEA,KAAK,uBAAuB;IAC5B,KAAK,aAAa;MAAE;QAClB,OAAOD,uBAAuB,CAACpC,IAAI,CAACyC,IAAI,EAAEJ,YAAY,CAAC,IACrDD,uBAAuB,CAACpC,IAAI,CAACoB,UAAU,EAAEiB,YAAY,CAAC,IACtDD,uBAAuB,CAACpC,IAAI,CAACqB,SAAS,EAAEgB,YAAY,CAAC;MACzD;IAEA,KAAK,cAAc;MAAE;QACnB,OAAOD,uBAAuB,CAACpC,IAAI,CAACsB,KAAK,EAAEe,YAAY,CAAC,IACtDD,uBAAuB,CAACpC,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAACuB,OAAO,CAACN,IAAI,EAAEoB,YAAY,CAAC,IACxED,uBAAuB,CAACpC,IAAI,CAACwB,SAAS,EAAEa,YAAY,CAAC;MACzD;IAEA,KAAK,iBAAiB;MAAE;QACtB,OAAOrC,IAAI,CAACyB,KAAK,CAACP,IAAI,CACnBQ,QAAQ,IAAK;UACZ,OAAOA,QAAQ,CAACN,UAAU,CAACF,IAAI,CAAES,GAAG,IAAK;YACvC,OAAOS,uBAAuB,CAACT,GAAG,EAAEU,YAAY,CAAC;UACnD,CAAC,CAAC;QACJ,CAAC,CACF;MACH;IAEA,KAAK,cAAc;IACnB,KAAK,iBAAiB;MACpB,OAAOrC,IAAI,CAAC0C,QAAQ,CAACxB,IAAI,CAAEyB,OAAO,IAAK;QACrC,OAAOP,uBAAuB,CAACO,OAAO,EAAEN,YAAY,CAAC;MACvD,CAAC,CAAC;IAEJ,KAAK,mBAAmB;MACtB,OAAOD,uBAAuB,CAACpC,IAAI,CAAC4C,KAAK,EAAEP,YAAY,CAAC;IAE1D,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;MAAE;QACxB,OAAOD,uBAAuB,CAACpC,IAAI,CAAC6C,IAAI,EAAER,YAAY,CAAC,IACrDD,uBAAuB,CAACpC,IAAI,CAAC4C,KAAK,EAAEP,YAAY,CAAC;MACrD;;IAEA;IACA,KAAK,oBAAoB;IACzB,KAAK,iBAAiB;MACpB,OAAOrC,IAAI,CAAC8C,WAAW,CAAC5B,IAAI,CAAE6B,aAAa,IAAK;QAC9C,OAAOX,uBAAuB,CAACW,aAAa,EAAEV,YAAY,CAAC;MAC7D,CAAC,CAAC;IAEJ,KAAK,eAAe;IACpB,KAAK,kBAAkB;MACrB,OAAOrC,IAAI,CAACgD,UAAU,CAAC9B,IAAI,CAAE+B,QAAQ,IAAK;QACxC,OAAOb,uBAAuB,CAACa,QAAQ,EAAEZ,YAAY,CAAC;MACxD,CAAC,CAAC;IACJ;IACA,KAAK,aAAa;IAClB,KAAK,kBAAkB;MACrB,OAAOrC,IAAI,CAACkD,UAAU,IAAIlD,IAAI,CAACkD,UAAU,CAAChC,IAAI,CAAEiC,SAAS,IAAK;QAC5D,OAAOf,uBAAuB,CAACe,SAAS,EAAEd,YAAY,CAAC;MACzD,CAAC,CAAC,IACArC,IAAI,CAACoD,QAAQ,IAAIhB,uBAAuB,CAACpC,IAAI,CAACqD,GAAG,EAAEhB,YAAY,CAAC,IAChED,uBAAuB,CAACpC,IAAI,CAACe,KAAK,EAAEsB,YAAY,CAAC;;IAErD;IACA,KAAK,gBAAgB;IACrB;IACA;IACA,KAAK,oBAAoB;IACzB;IACA,KAAK,eAAe;IACpB;IACA,KAAK,UAAU;MACb,OAAOrC,IAAI,CAACoD,QAAQ,IAAIhB,uBAAuB,CAACpC,IAAI,CAACqD,GAAG,EAAEhB,YAAY,CAAC,IACrED,uBAAuB,CAACpC,IAAI,CAACe,KAAK,EAAEsB,YAAY,CAAC;IACrD;IACA,KAAK,cAAc;MACjB;MACA,OAAOrC,IAAI,CAACoD,QAAQ,IAAIhB,uBAAuB,CAACpC,IAAI,CAACqD,GAAG,EAAEhB,YAAY,CAAC,IACrErC,IAAI,CAACsC,SAAS,CAACpB,IAAI,CAAES,GAAG,IAAK;QAC3B,OAAOS,uBAAuB,CAACT,GAAG,EAAEU,YAAY,CAAC;MACnD,CAAC,CAAC;IAEN,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;MACrB,OAAOD,uBAAuB,CAACpC,IAAI,CAACiB,IAAI,EAAEoB,YAAY,CAAC;IAEzD,KAAK,iBAAiB;IACtB,KAAK,eAAe;IACpB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;MACpB,OAAOD,uBAAuB,CAACpC,IAAI,CAAC4B,QAAQ,EAAES,YAAY,CAAC;IAE7D,KAAK,qBAAqB;MAAE;QAC1B,OAAOrC,IAAI,CAACsD,YAAY,CAACpC,IAAI,CAAES,GAAG,IAAK;UACrC,OAAOS,uBAAuB,CAACT,GAAG,EAAEU,YAAY,CAAC;QACnD,CAAC,CAAC;MACJ;IAEA,KAAK,oBAAoB;MAAE;QACzB,OAAOD,uBAAuB,CAACpC,IAAI,CAACuD,EAAE,EAAElB,YAAY,CAAC,IACnDD,uBAAuB,CAACpC,IAAI,CAACwD,IAAI,EAAEnB,YAAY,CAAC;MACpD;IAEA,KAAK,0BAA0B;MAC7B,OAAOD,uBAAuB,CAACpC,IAAI,CAACyD,KAAK,EAAEpB,YAAY,CAAC;;IAE1D;IACA;IACA,KAAK,0BAA0B;IAC/B,KAAK,kBAAkB;MACrB,OAAOD,uBAAuB,CAACpC,IAAI,CAAC0D,MAAM,EAAErB,YAAY,CAAC,IACvDD,uBAAuB,CAACpC,IAAI,CAACiD,QAAQ,EAAEZ,YAAY,CAAC;;IAExD;IACA,KAAK,QAAQ;IACb,KAAK,kBAAkB;MACrB,OAAOD,uBAAuB,CAACpC,IAAI,CAAC2D,MAAM,EAAEtB,YAAY,CAAC;IAE3D,KAAK,iBAAiB;MAAE;QACtB,IAAIrC,IAAI,CAAC4B,QAAQ,KAAK,IAAI,EAAE;UAC1B,OAAO,KAAK;QACd;QAEA,OAAOQ,uBAAuB,CAACpC,IAAI,CAAC4B,QAAQ,EAAES,YAAY,CAAC;MAC7D;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;IAEE;MACE,OAAO,KAAK;EAAC;AAEjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMuB,yCAAyC,GAAG,CAAC5D,IAAI,EAAE6D,kBAAkB,EAAEC,WAAW,KAAK;EAC3F,MAAMC,eAAe,GAAGD,WAAW,GACjC,CAACnC,GAAG,EAAEqC,aAAa,KAAK;IACtB,IAAIC,SAAS;IACb,IAAI;MACFA,SAAS,GAAGxD,cAAc,CAACkB,GAAG,EAAE,IAAI,EAAEqC,aAAa,CAAC;IACtD,CAAC,CAAC,OAAO/B,KAAK,EAAE;MACd;MACA,IAAIA,KAAK,CAACC,OAAO,KAAK,aAAa,EAAE;QACnC,OAAO,KAAK;MACd;;MAEA;MACA,MAAMD,KAAK;IACb;;IAEA;IACA;IACA,OAAOgC,SAAS,IAAInC,2BAA2B,CAACH,GAAG,EAAEqC,aAAa,CAAC;EACrE,CAAC,GACD,CAACrC,GAAG,EAAEqC,aAAa,KAAK;IACtB,OAAOvD,cAAc,CAACkB,GAAG,EAAE,KAAK,EAAEqC,aAAa,CAAC;EAClD,CAAC;EAEH,OAAOD,eAAe,CAAC/D,IAAI,EAAGkE,IAAI,IAAK;IACrC,IAAIL,kBAAkB,EAAE;MACtB,OAAO,IAAI;IACb;IAEA,IAAIzD,aAAa,CAAC8D,IAAI,CAAC,EAAE;MACvB,OAAO,KAAK;IACd;IAEA,MAAM,CACJ;MACE5D,MAAM;MACNW;IACF,CAAC,GAAG,CAAC,CAAC,CACP,GAAGiD,IAAI,CAAC5B,SAAS;IAElB,IAAI,EAAChC,MAAM,aAANA,MAAM,eAANA,MAAM,CAAEiC,MAAM,GAAE;MACnB,OAAO,KAAK;IACd;IAEA,MAAM,CACJ;MACEpC,IAAI,EAAEkC;IACR,CAAC,CACF,GAAG/B,MAAM;IAEV,OAAO8B,uBAAuB,CAACnB,IAAI,EAAEoB,YAAY,CAAC;EACpD,CAAC,CAAC;AACJ,CAAC;AAAC"}